# 第六章

这一章的内容比较简单啦，讲的是数据是怎么存储在计算机内部的，以及我们应该怎么做才能提高程序的性能

我们程序员能接触到的存储器，从靠近 CPU 到靠近硬盘的顺序来说，有

- SRAM
- DRAM
- 硬盘、闪存

## SRAM

SRAM 是一种只要通电了就能一直保存数据的**随机访问存储器**，它非常的快，主要用于 CPU 芯片的 L1、L2、L3 高速缓存中，它非常贵，大小通常在 几十KB 到 几MB 之间

比如我当前的电脑的 CPU 型号是 Intel Core i5-4278U，L1、L2、L3 缓存分别是 64KB、256KB、3MB

## DRAM

DRAM 是一种动态随机访问存储器，也就是俗称的内存，它也很快，但是比 SRAM 慢一些。现在（2019 年 10 月）在某宝上零售的内存，大小通常在 4GB 至 16GB 之间

DRAM 芯片的基本组成单元是超单元（supercell），一个超单元可以保存 w 位信息。一个 DRAM 上有 d 个超单元，因此可以这样的 DRAM 可以保存 dw 位数据。超单元排列成二维矩形，假设矩形有 r 行 c 列，那么 d = r * c

每个 DRAM 芯片连接到成为内存控制芯片（memory controller）的电路，DRAM 芯片与内存控制芯片之间有地址引脚和数据引脚。如果要读出某个超单元的内容，需要先通过地址引脚发送超单元的行地址、然后再通过地址引脚发送超单元的列地址到 DRAM 芯片，这两个过程分别叫做 RAS（行访问选通脉冲）和 CAS（列访问选通脉冲），DRAM 芯片会把超单元的 w 位数据通过数据引脚发送给内存控制芯片

为了提高 DRAM 的访问速度，计算机科学家们提出了多种技术

- **快页模式（Fast Page Mode DRAM，FPM DRAM）**。在传统 DRAM 中，如果内存芯片要读取一个超单元中的数据，数据读取超单元所在行的所有超单元数据到 DRAM 内的一个行缓冲区中，然后将对应列的超单元传送到地址引脚上，接着丢弃整个缓冲行。假设内存芯片一行有 4 个超单元，那么如果要读取这 4 个超单元的数据，内存控制芯片需要发送 4 次 RAS 和 CAS 请求。而有了 FPM 技术，内存芯片不会丢去行缓冲内容，这样内存控制器只需要发送一个 RAS 请求 和 CAS 请求、后面接着跟着 3 个 CAS 请求。这样能加快访问速度
- **扩展数据输出**。这是一个 FPM 技术的增强版，能让各个请求 CAS 在时间上靠的更近一些
- **同步 DRAM（Synchronous DRAM，SDRAM）**。能比普通 DRAM 更快的输出超单元内容
- **双倍数据速率同步 DRAM（Double Data-Rate Synchronous DRAM，DDR SDRAM）**。这是对 SDRAM 的增强
- **视频 RAM（Video RAM，VRAM）**

目前市面上的内存，大多是 DDR3 和 DDR4 内存了

CPU 和 DRAM 之间通过**总线（bus）**交换数据。总线是一组平行的导线，可以携带地址、数据和控制信号。将数据从 DRAM 读取到 CPU 的过程叫做**读事务**，从 CPU 写数据到主存的过程叫做**写事务**

目前主流的计算机系统中，总线被分为**系统总线（system bus）**和**内存总线（memory bus）**，系统总线连接 CPU 和 IO 桥，内存总线连接 IO 桥和 DRAM。IO 桥内有内存控制器等部件，他负责连接系统总线和内存总线，除此之外，他还负责连接外围 IO 设备，包括磁盘和显卡等

## 非易失性存储器

**非易失性存储器**保存的数据，即使在断电之后也不会丢失。一种常见的非易失性存储器是**只读存储器（Read Only Memory，ROM）**，ROM 通常会在嵌入式系统、计算机主板的 BIOS 作为固件

更常见的非易失性存储器是机械硬盘和闪存。机械硬盘将数据存储在圆形的盘片上，多个盘片组成圆柱形的盘片柱，读写头能够从盘片上读和写数据，盘片通过转动能让读写头读取不同位置上的数据，因此机械硬盘总是在不停的旋转

由于机械硬盘需要通过物理上的旋转来读取数据，因此速度并不快。现在像 SSD 这样的闪存，避免了旋转，能更快速的读取数据

## 局部性原理

局部性原理有两种表现形式：**时间局部性**和**空间局部性**。时间局部性是指，当一个内存地址被访问后，在不久的将来，它可能被再次访问。空间局部性是指，当一个内存地址被访问后，这个内存地址的附近的其他数据，也可能在不久的将来被访问到

为了利用局部性优化性能，计算机通常会把访问到的数据保存在 CPU 寄存器或者高速缓存中；在访问一个内存地址后，会把这个地址前后的内容也放入高速缓存里。这样当程序需要用到数据时，能直接从缓存中获得到数据，而不用再从内存中获取了

从缓存中读取数据比较简单，当缓存里有需要的数据时就直接读取，如果没有则从内存中加载到缓存，然后读取。写数据就比较复杂了。当要更新内存数据、且数据此时就在缓存中时，这个情况叫做**写命中（write hit）**，这时有两种方法来更新数据

- 一种写数据的方法叫做**直写（write-through）**，就是在缓存被更新后，立即将数据写到内存中，这种方法的有点是简单，缺点是每次更新数据都会导致总线流量。
- 另一种方法叫做**写回（write-back）**，他会尽可能的推迟把数据更新到内存中，直到缓存数据要被替换时才会写回到内存里，这种方法能减少总线流量，但是实现起来更加复杂。当一个缓存中的数据被更新了、还没有写到内存时，这个数据就被标记为脏数据（dirty）

当要写数据时，且数据不在缓存里时，这个情况叫做**写不命中（write-miss）**，它也有两个方法

- **写分配（write-allocate）**：把内存数据加载到缓存里，再更新缓存数据
- **非写分配（not-write-allocate）**：直接把数据写到内存里

直写高速缓存通常是非写分配的，写回高速缓存通常是写分配（要么简单到死，要么复杂到死）