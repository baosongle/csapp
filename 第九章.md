# 第九章

虚拟寻址，即是 CPU 通过生成一个虚拟地址（vitual address）来访问内存。在这个虚拟地址被送到主存之前，它需要被翻译成物理地址（physical address）。CPU 上有一个专门的翻译芯片 MMU（Memory Management Unit） 

虚拟地址空间和物理地址空间被都被划分为叫做页（page）的基本结构，虚拟地址空间内的页就成为虚拟页（virtual page，VP），物理地址空间的页就叫做物理页（physical page，PP），他们两者的大小都是相同的 

在任意时刻，虚拟页的集合都可以划分为三个不相交的子集 

- 未分配的：VM 系统还没有创建这个也 
- 缓存的：VM 系统创建了这个页，且对应的物理页也在主存中 
- 未缓存的：VM 系统创建了这个页，但是没有缓存在物理主存中 

没有被缓存的虚拟页保存在磁盘上，但是因为访问磁盘比访问主存慢了 100000 多倍，因此操作系统需要一个精确的算法，让虚拟页尽可能的被缓存。对主存的缓存，总是使用写回，而不是直写 

VM 系统需要通过一种方式来判断一个虚拟页是否缓存在了 DRAM 中的某个地方，如果是，需要知道物理页的具体地址，如果不是，则需要知道他在磁盘上的地址 

这种功能是通过操作系统软件、MMU和保存在内存中的叫做页表（page table）的数据结构完成。页表将虚拟页映射到物理页 

页表的每一个条目叫做页表条目（page table entry，PTE）。虚拟地址空间中的每一个虚拟页都在页表中有一个 PTE。每一个 PTE 都有一个有效位（valid bit）和 n 位的地址字段 

- 有效位是 1 表示虚拟页被缓存在了 DRAM 中，n 位地址就是就是物理页的起始地址 
- 有效位是 0 
- - 如果地址字段是空，表示虚拟页没有被分配 
  - 如果地址字段不是空，表示虚拟页已经分配，地址字段是物理页在磁盘上的起始地址 

一个进程经常访问的虚拟页的集合，叫做工作集（working set）。进程经常访问这些页面，因此页面都被缓存进了 DRAM，中，对页面的访问都能命中虚拟页表。但是当工作集的大小超过了物理内存的大小时，那么虚拟页会不断的从主存和磁盘上换入换出，导致性能急剧下降，这种现象叫做抖动（thrashing）。我自己有一个 8GB 主存的 Win10 电脑，当玩《文明6》时候如果选择了 12 人的大地图，那么就会经常发生抖动，游戏的帧率会大幅下降。但是这个时候查询到游戏的内存占用量有 1.5GB 

操作系统会每一个进程都分配了独立的页表，这意味着每个进程都有独立的虚拟地址空间。不同虚拟空间内的页可以映射到同一个物理页上 

使用虚拟内存的优势在于 

- 简化链接。独立的地址空间使得每个进程的内存映像使用相同的基本格式，而不用担心代码和数据实际存储于主存的何处。 
- 简化加载。在操作系统加载可执行文件和共享对象文件时，需要把目标文件的 .text 和 .data 节加载到新创建的进程里。在虚拟内存中，操作系统只需要在页表中分配好页，使得页指向目标文件，并不需要把物理页调入主存，即设置成未缓存状态，只有在进程实际获取物理页的数据时才把物理页换入。这样实际上减小了主存的流量，相当于我们在应用程序开发中常用到的懒加载模式 
- 简化共享。即不同进程的虚拟页可以指向相同的物理页 
- 简化内存分配。进程如果请求 k 个连续的页面，在主存上分配物理页时，这些物理页没必要是连续的 

虚拟内存还可以作为内存保护工具。因为访问内存必须经过内存翻译硬件读取一个 PTE，因此可以在 PTE 上增加一个额外的位来控制对虚拟页面的访问。可以向 PTE 添加 SUP 位表示进程是否必须运行在内核模式下才能访问该页面。添加 READ 和 WRITE 位控制对页面的读和写。如果进程违反了这些条件，那么 Linux 会抛出段错误（segmentation fault）

## 地址翻译

地址翻译就是把 n 位的虚拟地址 VA 映射到 m 位的物理地址 PA 的过程。

CPU 中有一个特殊的寄存器页表基址寄存器（Page Table Base Register，PTBR）指向当前页表的起始地址。n 位的虚拟地址包含两个部分：一个 p 位的虚拟页面偏移（Virtual Page Offset，VPO）和 (n-p) 位的虚拟页号（Virtual Page Number，VPN）。一个物理地址也有物理页面偏移 PPO 和物理页号 PPN。虚拟地址和物理页面的页面偏移的位数和值都是相等的

地址翻译的过程就是通过虚拟地址的 VPO 找到页表中的 PTE，根据 PTE 的有效位等其他位的判断后，找到对应的 PPN，将 PPN 和 VPO 结合就能得到物理地址

在地址翻译的过程中，如果每一个都需要去主存查询页表的话，应能可能会比较低。为提高性能，MMU 可能包含一个作为 PTE 缓存的翻译后背缓存器（Translation Lookaside Buffer，TLB）。如果 TLB 有 T=2^t 个组，那么 TLB 索引（TLBI）是由 VPN 的低 t 位组成，剩余 (p-t) 位是 TLB标记（TLBT）。这表示 TLBI 相同的虚拟页面都会缓存到相同的 TLB 组中

## 多级页表

目前我们所说的页表都是单级页表。如果虚拟地址由 32 位、每页 4KB、每个 PTE 4 字节，那么保存整个页表需要 4MB 内存空间。虽然说 4MB 的内存空间并不大，但是考虑到每个进程都需要一个页表，那么页表占用的空间还是挺可观的。而且大部分进程都只使用的虚拟空间的一小部分，因此如果可以通过某种方法压缩页表的话，可以节省下来很大的空间。压缩页表的一种方法是多级页表。

我们可以考虑两级页表。其中的一级页表的每个 PTE 负责映射到虚拟地址空间的 4MB 的片（chunk），每一片是二级页表，二级页表有 1024 的二级 PTE 组成。这样操作系统就能根据进程的需要分配相应的片了。在内存占用最小的情况下，进程需要一级页表和二级页表的一个片，这也两级页表占用的空间就是 4KB + 4KB = 8KB，相比于原来的 4MB 减小了 512 倍

## Intel Core i7 与 Linux 的内存分配

Intel Haswell 结构虽然允许完全的 64 位虚拟空间和物理空间，但是现在的 Core i7 实现支持 48位（256TB）虚拟地址空间和 52位（4PB）物理地址空间。此外，他还支持一个兼容模式，支持 32位（4GB）的虚拟和物理地址空间

一个典型的 Core i7 处理器内部包含下列部分

- 四个 CPU 核
  - 每个核内有包含一个层次的 TLB，TLB 是虚拟寻址的，四路组相连
  - 一个层次的数据高速缓存和指令高速缓存
  - 一组快速点到点链路，基于 QuickPath 技术，可以让每个核直接与外部 I/O 通信
- 所有核共享的 L3 高速缓存。L1、L2、L3 高速缓存是物理寻址的，块大小为 64 字节。L1、L2 是八路组相连，L3 是 16 路组相连
- DDR3 内存控制器
- 页大小可以在启动时配置成 4KB 或者 4MB

Linux 使用 4KB 的页

### Linux 虚拟内存系统

