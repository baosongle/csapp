# 第十章

在 Linux 中，一个文件就是一个 m 字节的序列。所有的 IO 设备（例如网络、磁盘和终端）都被模型化为设备。这种把设备都模拟成文件的方式，叫做 Unix IO，所有的 IO 操作都以下面的统一的方式进行

- 打开文件：打开一个文件后，内核返回一个非负整数，叫做**文件描述符**。之后所有对这个文件的操作都会使用文件描述符
- Linux shell 在创建每个进程后，都会为进程创建 3 个文件描述符：标准输入（描述符 0）、标准输出（描述符 1）、标准错误（描述符 2）
- 改变当前的文件位置：对于每个打开的文件，内核保持一个文件位置 k，初始为 0 。文件位置是从文件开头起始的字节偏移量，应用程序使用 `seek` 函数 能显式的改变文件位置
- 读写文件：读文件就是从文件中读取一些字节到内存里，读取了 n 个字节后，k 就会变成 k + n。如果读取文件后 k 的大小超过了文件的大小，那么就会触发一个 end of file （EOF）条件。写操作就是从内存复制 n 个字节到文件中，并更新 k 的值
- 关闭文件：当进程完成了对文件的访问后，需要显式的关闭文件，这样操作系统就能释放为打开文件创建的数据结构等，并将文件描述符释放到可用的描述符池中。无论当进程以什么原因终止时，内核都会释放进程打开的文件描述符

每个 Linux 文件都有一个类型来表示它在系统中的角色

- 普通文件：普通文件包含任意数据，可以分为文本文件（text file）和二进制文件（binary file）。对于内核而言，这两种文件没有任何区别
- 目录（directory）：目录是包含一组链接（link）的文件，其中每个链接都将一个文件名映射到一个文件，这个文件也可能是一个目录
- 套接字（socket）：套接字是用来与另一个进程进行跨网络通信的文件

其他的文件类型还包括命名通道（named pipe）、符号链接（symbolic link）、字符和块设备（character and block device）

书中提供了作者成为 RIO（Robust IO）的输入输出函数包，其中有无缓冲的输入输出函数和带缓冲的输入输出函数，是对 read 和 write 函数的简单封装

`rio_writen` 函数是对 `write` 函数的封装，它从缓冲区写特定的字节到文件中，而且不会返回不足值，实现的方法就是 while 循环不停的向文件写入数据，直到指定的数量的字节被写入了，而且写入过程不会被中断

类似的，`rio_readn` 是对 `read` 函数的封装，它也是在 while 循环中不停的从文件读取数据，直到指定的读取到指定的量的数据，同样在遇到中断后，还是继续读取

带缓冲的 `rio_read` 函数也是对 `read` 函数的封装，它维护一个 `rio_t` 的数据结构，内部带有缓冲区，当调用 `rio_read` 函数时，优先从缓冲区内读取数据，若缓冲区内没有数据，就调用 `read` 函数，尝试读取 `rio_t` 内缓冲区大小的数据量，这样就能最大化的减小调用 `read` 函数的次数，因为每次调用 `read` 函数都会陷入内核中，而陷入内核会对程序的性能造成很大的影响

### 共享文件

Linux 内核使用三个数据结构来表示打开的文件

- **描述符表（descriptor table）**：每个进程都有自己的描述符表，它的表项按照进程打开的文件描述符来索引，每个表项指向文件表的一个表项
- **文件表（file table）**：所有进程共享文件表，表示系统中打开的所有文件描述符。每个文件表的表项的内容包括当前文件的位置、引用计数和一个指向 v-node 表中对应表项的指针
- **v-node 表（v-node table）**：所有进程共享 v-node 表，每个表项包含文件的元数据

注意到文件表的表项中包含当前文件的位置信息，因此不管是相同进程或是不同进程，当打开磁盘上的相同文件，他们的文件描述符必定是不同的，对应的文件表的表项也是不同的，但是会对应相同的 v-node 表

当调用了 fork 函数后，子进程会共享父进程的打开的文件，文件表中的引用计数会加 1

### IO 重定向

IO 重定向可以把一个命令的输出当另一个进程的输入

### 标准 IO

C 语言提供了一组高级输入输出函数，成为标准 IO 库，包含 fopen、fclose 、fread 和 fwrite 函数等。标准 IO 库把文件模型化为一个流。对于程序员而言，每个流就是一个指向 FILE 类型的指针。每个 ANSI C 程序在开始时都有三个打开的流：stdin、stdout、stderr，分别对应标准输入、标准输出、标准错误